const path = require('path')
const fs = require('fs')
const util = require('util')
const mime = require('mime-types')
const fileType = require('file-type/index')

const stat = util.promisify(fs.stat)
const readDir = util.promisify(fs.readdir)
const readFile = util.promisify(fs.readFile)

const AWS = require('aws-sdk/index')

class Deployer {
  constructor (config) {
    if (!config) throw new TypeError('Config is required')

    config.awsConfig = {
      region: config.options.region,
      connectTimeout: 30 * 1000,
      timeout: 120 * 1000
    }
    const {accessKeyId, secretAccessKey} = config.options
    if (accessKeyId && secretAccessKey) {
      config.awsConfig = {
        ...config.awsConfig,
        accessKeyId,
        secretAccessKey
      }
    }

    this.config = config
  }

  // read asset path files
  fileList (dir) {
    return new Promise(resolve => {
      this.fileReader(dir)
        .then(flatten)
        .then(files => JSON.stringify(files, null, 2))
        .then(data => JSON.parse(data) || [])
        .then(data => {
          resolve(Promise.all(
            data
              .map(async item => {
                let file = await readFile(item)
                return {
                  filename: item,
                  buffer: file,
                  mime: contentType(item, file)
                }
              })
          ))
        })
        .catch(console.error)
    })
  }

  /**
   * recursive search all finder's files
   * @param dir
   * @returns {Promise.<*[]>}
   */
  async fileReader (dir) {
    const files = await readDir(dir)
    return Promise.all(files
      .map(f => path.join(dir, f))
      .map(async f => {
        const stats = await stat(f)
        return stats.isDirectory() ? this.fileReader(f) : f
      })
    )
  }

  // 创建 S3 上传实例
  async openConnection () {
    this.connection = new AWS.S3(this.config.awsConfig)
    console.log('Connection to S3 created')
  }

  // 开始上传
  async run () {
    await this._initUpload()
  }

  async _initUpload () {
    const rootDir = path.join(process.env.PWD, this.config.options.assetPath)

    console.time(`list [${rootDir}] all files`)
    const fileList = await this.fileList(rootDir)
    console.timeEnd(`list [${rootDir}] all files`)
    
    const start = Date.now()
    Promise.all(fileList
      .map(async (item) => {
        let extraPath = item.filename.replace(rootDir, '')
        let targetPath = path.join(this.config.options.targetPath, extraPath)

        console.time(`Uploading ${item.filename} => ${targetPath}`)
        await this.uploadFile(targetPath, item.buffer, item.mime)
        console.timeEnd(`Uploading ${item.filename} => ${targetPath}`)
      })
    ).then(_ => {
      const duration = (Date.now() - start) / 1000
      console.log(`all files are uploaded: ${duration}s`)
    }).catch(e => {
      console.log(e.toString())
    })
  }

  uploadFile (fileKey, fileStream, contentType) {
    let uploadParams = {
      Bucket: this.config.options.bucket,
      Body: fileStream,
      Key: fileKey,
      ACL: this.config.options.acl,
      ContentType: contentType
    }
    return this.connection.upload(
      uploadParams,
      { partSize: (5 * 1024 * 1024), queueSize: 4 }
    ).promise()
  }
}

function flatten (arr) {
  return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten), []);
}

function contentType (filename, fileStream) {
  return mime.lookup(filename) || fileType(fileStream) || 'application/octet-stream'
}

module.exports = Deployer
